\documentclass[12pt, a4paper]{report}

\input{preamble}

\input{environments}


\begin{document}

    \begin{figure}
        \centering
        \includegraphics[width=0.9\linewidth]{img/strasse1}
    \end{figure}
    
   \vspace*{1.2cm}
   \begin{center}
       {\huge Line Following Robot - Dokumentation}\\[0.8cm]
       \large{Fynn Raddatz, Erik Eismann, Julian Buck, Yannick Hecker}\\[0.5cm]
       \large{Betreuer: Prof. Chowanetz}\\[0.5cm]
       \today
       \thispagestyle{empty}
   \end{center}
   \newpage
   \tableofcontents
   %
   \clearpage
   %
   \pagestyle{fancy}
   \fancypagestyle{plain}{%
       \lhead{\textsc{Lfr}}
       \rhead{Raddatz, Eismann, Buck, Hecker}
       %	\renewcommand{\headrulewidth}{0pt}%
       %	\renewcommand{\footrulewidth}{0pt}%
   }

\chapter{Einleitung}

Transportsysteme in der Logistik oder Spurhalteassistenten im Auto sind nur zwei Beispiele für Anwendungen von Line-Following-Systemen. Diese gibt es in verschiedenen Ausführungen, aber unabhängig von der verwendeten Technik, liegt das Ziel dieses Systems darin, einer vorbestimmten Strecke zu folgen. Die Systeme werden beispielsweise beruhend auf einer induktiven oder magnetischen Linienerkennung entwickelt. Solche Markierungen müssen allerdings meist fest installiert werden. Für portable Lösungen bietet sich eine optische Realisierung des Line-Follwing an. Die Linien werden hierbei auf den Boden geklebt und können somit schnell angebracht und wieder entfernt werden. Die Erkennung der Linie erfolgt bei der dieser Variante beispielsweise über eine Kamera oder über optische Sensoren.

Im Folgenden wird die Konzeption und Entwicklung eines Line-Following-Robots im Rahmen einer Projektarbeit auf Basis der optischen Linienerkennung mit Hilfe von Infrarotsensoren dokumentiert. Zusätzlich wird die Implementierung und Funktionsweise einer Android App zur Steuerung des Roboters erläutert.\cite{schilling, schaefer, bosch} 


\chapter{Zielsetzung}\label{sec:Zielsetzung}

Ziel des Projekts ist es, einen Line-Following-Robot mit Mecanum-Rädern zu entwickelt, der über eine Android-App gesteuert werden kann. Dabei soll dieser über eine manuelle Steuerung, sowie über einen Automatikmodus verfügen, sodass er einer auf dem Boden markierten Linie folgen kann.

Um dieses Projekt realisieren zu können ist die Entwicklung einer eigenen Platine nötig, über die eine Ansteuerung der Motoren erfolgen kann. Außerdem soll die Spannungsversorgung des Roboters sowie das Auslesen diverser Sensordaten über diese Platine ermöglicht werden.

Für die Ansteuerung der Motoren ist ein eigener Algorithmus zu entwerfen, mit dem es möglich ist, die Vorteile der Mecanum-Räder auszunutzen. Des Weiteren ist die Projektierung einer UART-Verbindung mit einem eigenen Protokoll zur Datenübertragung zwischen dem STM und dem Raspberry Pi von Nöten. Zur Steuerung des Roboters soll eine Android App entwickelt werden, die über Bluetooth mit dem Raspberry Pi kommunizieren kann.

Im Anschluss soll eine Navigationsfunktion umgesetzt werden, die es ermöglicht, anhand von auf dem Boden angebrachten QR-Codes den Roboter an Kreuzungspunkten von Linien in eine bestimmte Richtung zu lenken. Die Navigation soll auch über die App erfolgen und ähnlich einer Routenfunktion funktionieren, indem man Checkpoints einspeichert, die der Roboter abfahren kann.


\chapter{Stand der Technik}\label{sec:StandDerTechnik}

Line-Following-Systeme werden bereits in der Industrie und Logistik für z.B. autonome Transportsysteme verwendet. Das Line-Following kann dabei in verschiedenen Formen realisiert werden, z.B. über Induktionsschleifen, magnetische Sensoren oder auch durch die optische Erkennung der Fahrspur.\cite{schilling, schaefer}

Neben Transportsystemen in der Logistik wird auch bei Spurhalteassistenten auf eine Art Line-Following zurückgegriffen. Hierbei kann beispielsweise mit Hilfe einer Videokamera der Abstand zu den Fahrspurmarkierungen gemessen werden. Abhängig von der gemessenen Distanz können dann Maßnahmen ergriffen werden, um das Fahrzeug in der Spur zu halten.\cite{bosch}


\chapter{Realisierung}\label{sec:Realisierung}

\section{Allgemeiner Aufbau des Roboters}

\subsection{Verwendete Teile und Konstruktion}

Der Roboter wird mit vier 12-Volt Motoren der Firma Pololu angetrieben. Es werden vier Mecanum-Räder mit 80 Millimeter Durchmesser eingesetzt. Die passenden Naben von Motoren auf Räder wurde selbst gefertigt. In Abbildung (\ref{img:Teile}) sind die genannten und alle weiteren für das Chassis verwendeten Teile zu sehen.

Es wird ein RaspberryPi 4 8GB eingesetzt und eine eigene Platine mit einem STM32 gefertigt. Die Bestückung der Platine sind in Kapitel \ref{sec:Platine} genauer beleuchtet.

Außerdem sind die Sensorhalterung und die Kamerahalterung 3D gedruckt worden.

Eine genaue Aufstellung aller Teile und deren Kosten ist der Excel-Tabelle \glqq Bauteilliste\grqq ~zu entnehmen.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.7\linewidth]{img/teile.jpg}
    \caption{Teile des Roboters}
    \label{img:Teile}
\end{figure} 
\FloatBarrier

\subsection{Schaltplan des technischen Aufbaus}

In Abbildung (\ref{Schematic}) ist der schematische Aufbau zu sehen. Es handelt sich um ein Zweiprozessorsystem mit einem STM32 und einem Raspberry Pi. Diese kommunizieren über \textit{UART}. Der STM32 liest sechs Infrarotsensoren mithilfe eines Analog-Digital-Wandlers aus, die für die Line-Following-Regelung benötigt werden. Außerdem steuert der STM die Motoren über H-Brücken und erhält Batteriestrom und -spannung über einen INA226. An den Raspberry Pi ist ein Button angeschlossen, um das Programm zu starten, sowie die Kamera, um QR-Codes zu erkennen. Der RaspberryPi kommuniziert mit der Android-App via Bluetooth.

\begin{figure}[h]
   \includegraphics[width=\linewidth]{img/Blockschaltbild_LRF_V003}
   \caption{Blockschaltbild des Roboters}
   \label{Schematic}
\end{figure}
\FloatBarrier

\subsection{UART-Kommunikation}\label{uart-code}

Die Datenübertragung des Line-Following-Robots zwischen STM und Raspberry Pi wird mittels UART implementiert. Für die Übertragung von Daten wurde ein generelles Schema festgelegt, damit die übertragenen rohen Daten von den Systemen interpretiert werden können. Um den Startpunkt einer Nachricht zu markieren, wird ein fest definiertes Byte verwendet (PRIMARY\_ID). Nur Nachrichten, die mit dieser Id beginnen, werden vom STM und dem PI als valide angesehen. Das zweite gesendete Byte (CMD\_ID) deklariert, welche Daten genau in dieser Nachricht übertragen werden. Nach der Spezifizierung der Nachricht werden die tatsächlich relevanten Daten übertragen. Um diese zu verifizieren, wird am Ende jeder Nachricht ein Byte als Prüfsumme verwendet, die aus einer XOR-Verknüpfung der gesamten Nachricht entsteht. Nur wenn der Empfänger selbst die selbe Prüfsumme aus den empfangen Bytes berechnet, werden die Daten übernommen. Im Folgenden ist der Aufbau einer Nachricht noch einmal veranschaulicht:

\Kotlin{AufbauEinerNachricht.txt}{1}{1}



\captionsetup{justification=centering,margin=1cm}
\section{Funktion und Design der Platine}\label{sec:Platine}
      Im Verlauf des Projekts wurde eine eigene Steuerplatine (folgend einfach \glqq die Platine\grqq, bzw. \glqq das PCB\grqq) mit
      einem STM32 Mikrocontroller geplant und angefertigt. Mit dieser konnte die Erzeugung der verschiedenen
      Spannungslevel, die Ansteuerung der Motoren sowie die Auswertung der Sensorik kompakter und effizienter umgesetzt werden. Zur
      Planung wurde \glqq Altium Designer\grqq~verwendet. Bestellt wurde das PCB bei JLCPCB, die Bestückung wurde per Hand durchgeführt.
         \subsection{Funktionen}
         Die Hauptfunktionen der Platine sind:
         \begin{itemize}
            \item Wandlung der Akkuspannung in 5V und 3.3V
            \item Messung der Akkuspannung und des Akkustroms
            \item Ansteuerung der vier Motoren
            \item Auslesen der Infrarotsensoren
            \item Ansteuerung der LEDs
            \item Weiterleiten der Daten an und empfangen der Steuerkommandos vom Raspberry Pi
         \end{itemize}
         \subsection{Hardwarekomponenten}
            \subsubsection{LM2678 Buck Converter}
            Um alle Komponenten auf der Platine und den Raspberry Pi aus dem Bleiakku zu speisen, bedarf es eines Buck Convertes, der die schwankende Akkuspannung auf ein niedrigeres konstantes Potential wandelt.
            Hierfür wurde ein LM2678 Buck Converter IC in der 5V Festspannungsvariante verbaut. Mit 5A maximalem Ausgangsstrom bietet dieser ausreichend Leistung, um sowohl den Raspberry Pi als auch alle anderen angeschlossen Komponenten zuverlässig zu versorgen, und das bei einer geringen Anzahl von benötigten Zusatzkomponenten.
            Mit der bekannten Topologie aus Spule und Diode ergibt sich folgendes Schaltbild. 
            \begin{figure}[H]
               \centering
               \includegraphics[width=\linewidth]{img/lm2678.png}
               \caption{Beschaltung des LM2678-5.0 Buck ICs}
            \end{figure}
            Das Rückmessen der Ausgangsspannung über den Feedback Pin (FB) schließt den Regelkreis. Der Raspberry Pi wird direkt über einen USB-A Port auf der Platine versorgt, während die meisten anderen Komponenten über den Linearregler gespeist werden, siehe (\ref{ams1117}).
            \subsubsection{AMS1117 Linearregler}\label{ams1117}
            Das 5V Potential wird weiter über einen AMS1117-3.3 Linearregler auf 3.3V gesenkt. Hieraus werden dann der STM32 sowie weitere ICs versorgt. Es werden nur wenige Kondensatoren zur Entstörung und Stabilisierung benötigt. Der Maximalstrom beträgt 800mA. Durch die geringen Anforderungen an den Regler wurde der generische AMS1117 gewählt, da er bereits in großer Stückzahl zur Verfügung stand.
            \begin{figure}[H]
               \centering
               \includegraphics[width=0.5\linewidth]{img/ams1117.png}
               \caption{Beschaltung des AMS1117-3.3 Festspannungsreglers}
            \end{figure}
         

            \subsubsection{INA226 Power Monitor}
            Akkustrom- und spannung werden über einen INA226 Power Monitor IC gemessen. Dazu wird der gesamte Akkustrom durch einen 10$\si[]{\milli\ohm}$-Shunt geführt. Die Shuntspannung wird dann über die IN+ und IN- Pins gemessen. Mit einer maximal messbaren Shuntspannung von $\pm 81.9\si[]{\milli\volt}$ ergibt sich also ein erfassbarer Strom von ca. $\pm 8.2\si[]{\ampere}$.
            Die Messung der Akkuspannung erfolgt separat über den VBUS Pin.
            \begin{figure}[H]
               \centering
               \includegraphics[width=0.7\linewidth]{img/ina226.png}
               \caption{Beschaltung des INA226 Power Monitor ICs mit Shunt Widerstand in High-Side-Konfiguration}
            \end{figure}
            Die Kommunikation mit dem Mikrocontroller erfolgt über einen I$^2$C-Bus mit der Datenleitung SDA und der Clockleitung SCL. Über die Pins A1 und A0 kann die I$^2$C-Adresse konfiguriert werden, hier wurde 0x41 gewählt. Genauere Informationen zur Ansteuerung und Auswertung können im Kapitel (\ref{ina226-software}) nachgelesen werden.
            \subsubsection{CNY70 Infrarotsensoren}
            Die Erkennung einer schwarzen Linie auf weißem Untergrund zum Line Following erfolgt über sechs CNY70 Infrarotreflexsensoren. Diese bestehen aus einer Infrarot-LED und einem Phototransistor.
            \begin{figure}[H]
               \centering
               \includegraphics[width=0.6\linewidth]{img/cny70.png}
               \caption{CNY70 mit schematischer Darstellung der Bestandteile}
            \end{figure}
            Die LEDs werden konstant bestromt und leuchten dauerhaft, der Vorwiderstand befindet sich auf der Platine. Der Emitter des Transistors wird über einen 10$\si[]{\kilo\ohm}$-Widerstand mit GND verbunden, an dem der Spannungsabfall gemessen wird.
            Die Sensoren werden mit einem Flachbandkabel und einem 24 poligen Wannenstecker verbunden. Die Auswertung erfolgt über einen separaten ADC (\ref{ads7828}).
            \begin{figure}[H]
               \centering
               \includegraphics[width=0.6\linewidth]{img/wannenstecker.png}
               \caption{Wannenstecker zum Anschluss der IR-Sensoren mit Beschaltung für jeden Sensor}
            \end{figure}
            \subsubsection{ADS7828 ADC}\label{ads7828}
            Alle Infrarotsensoren werden jeweils analog über einen Analog-Digital-Converter ausgewertet. Hierfür wurde ein zusätzlicher IC verwendet, um Pins am STM zu sparen und die Auswertung einfacher zu gestalten. Verwendet wurde ein ADS7828 8 Channel ADC mit 12 Bit Auflösung und I$^2$C-Interface.
            Die übrigen zwei Channel werden zur Überwachung der 5V Spannung und der Akkuspannung verwendet. Diese sind über Spannungsteiler verbunden. Der ADC wird über eine interne 2.5V Referenzspannung betrieben.
            \begin{figure}[H]
               \centering
               \includegraphics[width=0.5\linewidth]{img/ads7828.png}
               \caption{Beschaltung des ADS7828 8 Channel ADC ICs}
            \end{figure}
            \subsubsection{L6206PD Motortreiber}\label{l6206pd}
            Die vier 12V DC-Motoren werden über zwei L6206PD Motortreiber per PWM angesteuert. Jeder Treiber besteht aus zwei DMOS-Vollbrücken, die jeweils mit einem Motor verbunden sind. Die Grundbeschaltung lässt sich aus folgendem Bild entnehmen.
            \begin{figure}[H]
               \centering
               \includegraphics[width=0.6\linewidth]{img/l6206pd.png}
               \caption{Pinbelegung und Anschlussbezeichnungen eines Motortreibers}
            \end{figure}
            Die Schaltung der erforderlichen Charge-Pump ist in Abbildung (\ref{chargepump-img}) dargestellt.
            \begin{figure}[H]
               \centering
               \includegraphics[width=0.4\linewidth]{img/chargepump.png}
               \caption{Charge-Pump-Schaltung für einen Motortreiber}\label{chargepump-img}
            \end{figure}
            Die Motortreiber verfügen über verschiedene Features und Schutzeinrichtungen. Das programmierbare Stromlimit ist für jede Brücke auf das Maximum (2.8A) festgelegt, indem jeweils der PROGCLx Pin direkt mit GND verbunden wurde.
            Im Überstrom- oder Übertemperaturfall schaltet der zugehörige Overcurrent-Detection-Pin (OCDx) auf GND (Open-Drain-Schaltung). Die folgende Grafik zeigt die OCDx Pinbeschaltung.
            \begin{figure}[H]
               \centering
               \includegraphics[width=0.25\linewidth]{img/ocd.png}
               \caption{Beschaltung des OCDx Pins am Motortreiber}
            \end{figure}
            Der OCDx Pin ist direkt mit dem Enable Pin des Motortreibers verbunden. Dieser ist im Normalbetrieb über einen 100$\si[]{\kilo\ohm}$ Pull-Up-Widerstand auf 5V gezogen und somit aktiv, wie die obige Abbildung zeigt.
            Im Fehlerfall (OCDx auf GND) wird der Enable Pin ebenfalls LOW, der Motortreiber schaltet automatisch ab. Über eine 5.6$\si[]{\nano\farad}$ Kapazität wurde eine geringe Abfallverzögerung von etwa 200$\si[]{\micro\second}$ realisiert.
            Des Weiteren ist jeder OCDx Pin mit einem GPIO-Pin des Mikrocontrollers verbunden. So kann zum Einen der Fehlerfall detektiert werden, oder, bei Bedarf, der Motortreiber manuell deaktiviert werden.
            \subsubsection{STM32 Mikrocontroller}
            Die Steuerung aller verbauten Sensoren und weiteren ICs sowie die Kommunikation mit dem Raspberry Pi übernimmt ein STM32F103C8T6 Mikrocontroller mit 64kB Flash und 72MHz Taktfrequenz. Es werden alle 37 GPIO Pins genutzt, wie die folgende Grafik zeigt.
            \begin{figure}[H]
               \centering
               \includegraphics[width=0.75\linewidth]{img/stm32.png}
               \caption{Pinbelegung des STM32 Mikrocontrollers}
            \end{figure}
            Die Motoransteuerung erfolgt über vier PWMx Pins, die über einen Hardwaretimer gesteuert werden (siehe hierzu (\ref{hardwaretimer}) und (\ref{motorcontrol})).
            Zur Richtungssteuerung werden außerdem vier weitere GPIOs benötigt (DIRx). Wie in (\ref{l6206pd}) beschrieben, werden vier GPIOs zur Fehlerdetektion der Motortreiber genutzt. Zur Rückmessung der Motordrehzahlen sind zwei Encoder-Pins pro Motor in Benutzung.
            Drei On-Board Status-LEDs werden über STATx angesteuert. Ein LED Streifen wird über den Pin LEDStrip betrieben. Die Auswertung des INA226 sowie des ADS7828 erfolgt über I$^2$C. Die Kommunikation mit dem Raspberry Pi erfolgt über UART3. UART1 ist zur Ausgabe von Debug-Nachrichten vorgesehen. 
            Programmiert wird die MCU über die Pins SWCLK und SWIO (JTAG Interface) mit einem ST-Link. Die weitere Beschaltung ist im Folgenden dargestellt.
            \begin{figure}[H]
               \centering
               \includegraphics[width=0.7\linewidth]{img/oscillators.png}
               \caption{8MHz und 32.768kHz Quarze}
            \end{figure}
            \begin{figure}[H]
               \centering
               \includegraphics[width=0.7\linewidth]{img/filtercaps.png}
               \caption{Filter und Stabilisierung der Spannungspins}
            \end{figure}
            Zur Auswahl des STM32 Boot-Modes werden die zwei Boot Pins BOOT0 und BOOT1 verwendet. BOOT0 kann über einen Jumper gesetzt werden, um zwischen dem Boot aus dem Flash und zwischen dem Programmiermodus zu wechseln.
            \begin{figure}[H]
               \centering
               \includegraphics[width=0.5\linewidth]{img/bootselect.png}
               \caption{Beschaltung der zwei Boot Pins}
            \end{figure}
            Zuletzt ist die Beschaltung des Reset Pins (NRST) gezeigt. Der Reset erfolgt über einen Button auf der Platine. Der Pull-Up definiert den Pegel im Normalbetrieb. Außerdem wurde ein Kondensator zum Entprellen vorgesehen.
            \begin{figure}[H]
               \centering
               \includegraphics[width=0.5\linewidth]{img/resetbtn.png}
               \caption{Beschaltung des Reset Pins}
            \end{figure}
             \subsubsection{Layout und finales PCB}
             Die Platine wurde in drei Bereiche aufgeteilt, in denen jeweils zusammengehörige Komponenten positioniert wurden. Im linken Bereich befinden sich alle Logikbausteine mit der MCU im Zentrum. In der Mitte sind die Hauptbestandteile der Stromversorgung platziert. Im rechten Bereich befinden sich die Motortreiber mit Zusatzbeschaltung.
             Es wurde insgesamt drauf geachtet, Komponenten und Baugruppen mit hohem elektromagentischem Störpotential weit von den vergleichsweise empfindlichen Logik-ICs anzuordnen. Somit wurden die Motortreiber sowie die Induktivität des Buck-Converters am weitesten rechts platziert.
             Durchgängige Ground-Planes auf Ober- und Unterseite des PCBs sind über Via-Stitching miteinander verbunden und tragen so zur elektromagentischen Verträglichkeit bei. 
          \begin{figure}[H]
          \centering
          \includegraphics[width=0.7\linewidth]{img/pcb3d.png}
          \caption{3D-Ansicht der Platine}
          \end{figure}
   
         
         \newpage
      \subsection{STM32 Mikrocontroller}
         \subsubsection{Konfiguration}
         Die Konfiguration und die Programmierung des STM32 erfolgt mittels der STM32 Cube IDE. Hiermit kann die gesamte Hardware graphisch konfiguriert sowie der C++ Code kompiliert und hochgeladen werden.
         \subsubsection{Clockkonfiguration}
         Zur Verwendung des vollen 72MHz Clocktakts muss dieser konfiguriert werden. Des Weiteren muss angegeben werden, dass die externen Quarze mit 8MHz und 32.768kHz verbaut sind.
         \begin{figure}[H]
            \centering
            \includegraphics[width=0.7\linewidth]{img/rccmode.png}
            \caption{RCC Config für externe Quarze}
         \end{figure}
         \begin{figure}[H]
            \centering
            \includegraphics[width=\linewidth]{img/clockconfig.png}
            \caption{Gesamte Clockconfiguration des STM32}
         \end{figure}
         \subsubsection{GPIO-Pins}
         Für jeden GPIO Pin wurde die gewünschte Funktion eingestellt, wobei manche lediglich Initialisierungswerte sind die im laufenden Betrieb dynamisch geändert werden.
         Hervorzuheben sind die Kommunikationsinterfaces, die im nachfolgenden Kapitel näher konfiguriert werden. 
         Außerdem wurden die Pins für die Programmierung, die Boot-Mode Auswahl sowie für die externen Oszillatoren definiert. Besonderheiten ergeben sich beim Pin für den LED-Streifen, hier musste die GPIO-Geschwindigkeit auf High gestzt werden um der hohen Schaltgeschwindigkeit gerecht zu werden. Siehe hierzu (\ref{ws2812}).
         \begin{figure}[H]
            \centering
            \includegraphics[width=0.7\linewidth]{img/pinmap.png}
            \caption{Alle konfigurierten GPIOs des Mikrocontrollers}
         \end{figure}
         
         \subsubsection{UART-Pins}
         Zur Kommunikation mit dem Raspberry Pi sowie zur Ausgabe von Debug Nachrichten werden zwei UART-Interfaces genutzt, USART1 an den Pins PB6 und PB7 und USART3 an den Pins PB10 und PB11. Die Konfiguration ist identisch. Gewählt wurde
         ein Baudrate von 115200 b/s, 8 Bit Wordlength, keine Parity und ein Stop-Bit (8N1). Außerdem wurden bei beiden RX-Pins Interrupts aktiviert, um Nachrichten ohne Polling zu empfangen. Siehe hierzu (\ref{uart-code}).
         \begin{figure}[H]
            \centering
            \includegraphics[width=0.6\linewidth]{img/uart-config.PNG}
            \caption{Konfiguration der UART-Interfaces}
         \end{figure}
         \subsubsection{I2C-Pins}
         Bei den Pins für den I$^2$C-Bus I2C1 an den Pins PB8 und PB9 wurden keine besonderen Einstellungen vorgenommen. Der Speed Mode wurde auf Standard mit 100kHz Clocktakt gelassen.
         \begin{figure}[H]
            \centering
            \includegraphics[width=0.5\linewidth]{img/i2c-config.PNG}
            \caption{Konfiguration des I2C-Interface}
         \end{figure}
         \subsubsection{Hardwaretimer}\label{hardwaretimer}
         Umfangreiche Einstellungen mussten bei der Verwedung der Hardwaretimer vorgenommen werden. Der Mikrocontroller verfügt über vier unabhängige Hardwaretimer Channel, von denen drei verwedet werden.
         \newpage
         \textbf{TIMER1}\label{timer1}\\
         \textit{TIMER1} steuert die vier PWM Channel, die für die Motoransteuerung verwendet werden. Hierbei wurde zunächst die Clocksource auf \textit{Internal Clock} festgelegt. Außerdem wurden vier Chanel zur PWM-Ausgabe konfiguriert.
         \begin{figure}[H]
            \centering
            \includegraphics[width=0.6\linewidth]{img/pwm-channel.PNG}
            \caption{Aktivierung der vier PWM-Channel}
         \end{figure}
         Weiter muss die PWM-Frequenz gesetzt werden. Dazu sind zwei Rechnungen nötig.
         Unter der Vorraussetzung, dass der Timer mit dem Clocktakt von 72MHz tickt, wird zunächst ein Prescaler von 72 festgestzt. Damit ist der Timer auf eine Frequenz von
         \begin{align}
            f_{\mathrm{TIM1}}=\dfrac{72\si[]{\mega\hertz}}{72}=1\si[]{\mega\hertz}
         \end{align}
         programmiert. Jetzt muss die \textit{Counter Period} gewählt werden. Diese definiert, bei wie vielen Ticks das CNT Register des Timers überläuft und zurückgesetzt wird (Rollover). Die PWM-Frequenz ist mit dieser Einstellung untrennbar verknüpft, denn die Frequenz mit der Rollovers stattfinden entspricht der Frequenz des PWM-Signals.
         Bei einer Sollfrequenz von $f_{\mathrm{PWM}}=2\si[]{\kilo\hertz}$ ergibt sich also 
         \begin{align}
            \mathrm{PERIOD}=\dfrac{f_{\mathrm{TIM1}}}{f_{\mathrm{PWM}}}=\dfrac{1\si[]{\mega\hertz}}{2\si[]{\kilo\hertz}}=500
         \end{align}
         \begin{figure}[H]
            \centering
            \includegraphics[width=0.5\linewidth]{img/tim1-config.PNG}
            \caption{Einstellung von Prescaler und Counter Period für TIM1}
         \end{figure}
         Der Duty Cycle kann über einen \textit{Compare}-Wert vorgegeben werden. Siehe hierzu (\ref{motorcontrol}).

         \textbf{TIMER2}

         \textit{TIMER2} ist mit einem Prescaler von 14400 ($f_{\mathrm{TIM2}}=5\si[]{\kilo\hertz}$) im Betrieb und für die Aktualisierung des LED-Streifens verwendet, sofern Animationen in Benutzung sind. Die Frequenz wird im Programmablauf weiter gesenkt, sodass eine Aktualisierung nur noch wenige Male in der Sekunde sattfindet.

         \textbf{TIMER3}

         \textit{TIMER3} wird zur zeitlichen Steuerung der UART-Kommunikation genutzt. Über ihn wird festgelegt, in welchen Intervallen Nachrichten versendet werden. Dabei wird über den Timer eine Grundfrequenz eingestellt, die die Senderate der häufigsten Nachricht festlegt.
         Weitere Nachrichten werden mit einer Frequenz gesendet, die über einen ganzzahligen Teiler der Grundfrequenz berechnet wird.
         \newpage
         \subsubsection{Funktionsweise des auf dem STM laufenden Programms}
            \subsubsection{UART-Kommunikation}
                 Die Kommunikation vom STM zum Raspberry Pi wurde wie in \ref{uart-code} beschrieben mit UART implementiert. Auf der Seite des STMs wird zwischen vier Nachrichtentypen unterschieden, die an den Raspberry Pi gesendet werden. Die Unterscheidung der Nachrichten erfolgt durch unterschiedliche CMD\_IDs, die wie folgt definiert sind:
   
              \begin{table}[h]
                 \centering
                 \begin{tabular}{l|l|c|c|l|}
                    \cline{2-5}
                    & \textbf{Funktion} & \multicolumn{1}{l|}{\textbf{CMD\_ID}} & \multicolumn{1}{l|}{\textbf{Länge in Bytes}} & \textbf{Inhalt der Nachricht}                                                               \\ \cline{2-5} 
                    & batteryStatus     & 0x05                                  & 16                                           & \begin{tabular}[c]{@{}l@{}}- Batteriespannung\\ - Batteriestrom\end{tabular}                \\ \cline{2-5} 
                    & sensorStatus      & 0x0F                                  & 16                                           & - Daten der Infrarotsensoren                                                                \\ \cline{2-5} 
                    & motorStatus       & 0x0A                                  & 16                                           & \begin{tabular}[c]{@{}l@{}}- Motorgeschwindigkeit\\ - Umdrehungszahl der Räder\end{tabular} \\ \cline{2-5} 
                 \end{tabular}
              \end{table}
              Das Lesen von Nachrichten erfolgt über Interrupts. Wurde eine vorher festgelegte Anzahl von Bytes empfangen, wird ein Interrupt ausgelöst und ein Flag-Bit gesetzt. Im nächsten Main-Durchlauf erfolgt dann eine Auswertung des RX-Buffers.
                 
            \subsubsection{Auslesen der Infrarotsensoren}\label{ads7828-software}
            Alle Infrarotsensoren werden analog ausgewertet und sind jeweils mit einem Channel des ADS7828 Analog-Digital-Wandlers verbunden, welcher die Daten über I$^2$C weiterleitet.
            Folgendes Schaltbild soll den Anschluss noch einmal verdeutlichen.
            \begin{figure}[H]
               \centering
               \begin{circuitikz}
                  \draw node[vcc](5V) at (0,0){\SI{+5}{V}};
                  \draw node[ground](GND1) at (0,-6){};
                  \draw (5V.south) to[R, l=$330$] ++(0,-2) to[full led] ++(0,-2) -- (GND1.north);
                          
                                 
                  \draw node[vcc](VCC) at (3,0){\SI{+3.3}{V}};
                  \draw (3,-3) node[npn,photo](transe){};
                  \draw (VCC.south) -- (transe.collector);
                  \draw node[ground](GND2) at (3,-6){};
                  \draw (transe.emitter) to[R, l=$10\mathrm{k}$] (GND2.north);
                  \draw (transe.emitter) to[short,-o] ++(2,0) node[anchor=west]{CHx};
               \end{circuitikz}
               \caption{Beschaltung der CNY70 Infrarotsensoren mit Anschluss an einen ADC Channel CHx}
            \end{figure}
            Die I$^2$C-Kommandos sind simpel aufgebaut. Nach einen typischen Adressbyte, welches die I$^2$C-Adresse sowie das READ/$\overline{\mathrm{WRITE}}$ Bit enthält, folgt ein Command Byte.
            \begin{figure}[H]
               \centering
               \includegraphics[width=0.7\linewidth]{img/ads7828-commandbyte.png}
               \caption{Aufbau eines Command Bytes}
            \end{figure}
            Mit SD wird der Messmodus festgelegt, hier $\mathrm{SD}=1$ für Messungen mit gemeinsamem Referenzpotential. Mit PDx kann der Power Down Modus gesetzt werden. Für dauerhaft aktivierte A/D-Wandlungen und Nutzung der internen 2.5V Referenzspannung gilt $\mathrm{PD1}=\mathrm{PD0}=1$.
            Über die drei Cx Bits erfolgt die Wahl des auszuwertenden Channels. Folgende Tabelle zeigt die möglichen Kombinationen.
            \begin{figure}[H]
               \centering
               \includegraphics[width=0.8\linewidth]{img/ads7828-channelselection.png}
               \caption{Möglichkeiten bei der Channel Auswahl}
            \end{figure}
            Bei richtigem Kommando erfolgt die Rückgabe von zwei Bytes, in denen der 12 Bit Messwert enthalten ist.
            Zur Auswertung der Infrarotsensoren im Code werden die Channel 0 - 5 hintereinander abgefragt.
            \subsubsection{Messung der Akkuparameter}\label{ina226-software}
            Die Messung von Akkuspannung und -strom erfolgt über den INA226, welcher ebenfalls über I$^2$C angebunden ist. Während Shunt- und Busspannung direkt abgefragt werden können, bedarf es für das Messen von Stromstärke und Leistung einiger Rechnungen und Konfigurationen.
            Zunächst wird die Auflösung des Stroms, also das LSB, geschätzt.
            \begin{align}
               \mathrm{LSB_{CUR}}=\dfrac{I_{\mathrm{MAX}}}{2^{15}}\approx \dfrac{8\si[]{\ampere}}{2^{15}}\approx 244\si[]{\micro\ampere}
            \end{align}
            Zur besseren Berechnung wird großzügig aufgerundet, $\mathrm{LSB_{CUR}}\approx 500\si[]{\micro\ampere}$.\\
            Der zu programmierende Wert des Kalibirierungsregisters \textit{CAL} berechnet sich dann mit 
            \begin{align}
               \mathrm{CAL}=\dfrac{0.00512\si[]{\ampere\ohm}}{\mathrm{LSB_{CUR}}\cdot R_{\mathrm{SHUNT}}}=\dfrac{0.00512\si[]{\ampere\ohm}}{500\si[]{\micro\ampere}\cdot 10\si[]{\milli\ohm}}=1024\label{ina-calib}
            \end{align}
            Der INA226 verfügt über vier Register, die Messwerte in Form von einheitenlosen 16 Bit Ganzzahlen beinhalten. Diese sind
            \begin{align*}
               \mathrm{SHUNTVOL} && \mathrm{BUSVOL} && \mathrm{CURRENT} && \mathrm{POWER}
            \end{align*}
            Die Messwerte müssen nach dem Abfragen in physikalische Größen konvertiert werden. Zuerst werden die zwei Spannungen berechnet. Es gilt
            \begin{align}
               U_{\mathrm{SHUNT}}=\mathrm{SHUNTVOL}\cdot 2.5\si[]{\micro\volt} && U_{\mathrm{BUS}}=\mathrm{BUSVOL}\cdot 1.25\si[]{\milli\volt}
            \end{align}
            Strom und Leistung berechnen sich dann über
            \begin{align}
               I_{\mathrm{SHUNT}}=\mathrm{CURRENT}\cdot \mathrm{LSB}_{\mathrm{CUR}} && P_{\mathrm{BUS}}=\mathrm{POWER}\cdot \mathrm{LSB}_{\mathrm{CUR}}\cdot 25\si[]{\volt}
            \end{align}
            Die Ansteuerung erfolgt über eine eigene INA226 Klasse. Die Kalibrierung nach Formel (\ref{ina-calib}) wird beim Programmstart durchgeführt, danach kann jeder Messwert auf Anforderung einzeln abgerufen werden.
            Das Aussenden der Akkuparameter geschieht etwa alle 500$\si[]{\milli\second}$.
            \subsubsection{Motoransteuerung}\label{motorcontrol}
            Jeder Motortreiber IC enthält zwei Vollbrücken, an die jeweils ein Motor angeschlossen werden kann, siehe (\ref{l6206pd}). Exemplarisch wird die Ansteuerung an einem Motor und einer Vollbrücke erläutert, wobei zur weiteren Vereinfachung der Treiber mit der Vollbrücke als \glqq Black-Box\grqq~dargestellt wird. Folgendes Schaltbild dient als Grundlage.
            \begin{figure}[H]
               \centering
               \begin{circuitikz}
                  \node[draw,minimum width=2cm,minimum height=4cm,anchor=south] at (0,0)(driver){L6206PD}
                  ($(driver.west)!0.75!(driver.north west)$) coordinate (in1)
                  ($(driver.west)!0.75!(driver.south west)$) coordinate (in2)
                  ($(driver.east)!0.75!(driver.north east)$) coordinate (out1)
                  ($(driver.east)!0.75!(driver.south east)$) coordinate (out2);

                  \draw (in1) to[short,-o, l_=in1] ++(-1,0) to[short,-*] ++(-2,0) to[open] ++(-0.2,0) node[anchor=east]{PWMx};
                  \draw (in2) to[short,-o, l_=in2] ++(-1,0) to[short,-*] ++(-2,0) to[open] ++(-0.2,0) node[anchor=east]{DIRx};
                  \draw (out1) to[short,-o, l=out1] ++(1,0) -- ++(1,0) coordinate (motorTop) ++(0.8,0) coordinate (motorTopR);
                  \draw (out2) to[short,-o, l=out2] ++(1,0) -- ++(1,0) coordinate (motorBot) ++(0.8,0) coordinate (motorBotR);
                  \draw (motorTop) to[Telmech=M,n=motor] (motorBot);
                  \draw (motorTopR) to[open, v^=$U_{\mathrm{MTR}}$] (motorBotR);
               \end{circuitikz}
               \caption{Stark vereinfachte Beschaltung des Motors}
            \end{figure}
            Die logischen Eingänge in1 und in2 entsprechen den Ausgängen out1 und out2, wobei die Ausgangsspannung der Batteriespannung entspricht. Die folgende Tabelle erläutert diesen Zusammenhang.
            
            
            \begingroup
            \fontfamily{phv}\selectfont
            \setlength{\tabcolsep}{20pt}
            \begin{table}[H]
               \sffamily
               \centering
               \begin{tabular}{|cc|cc|}
               \hline
               \multicolumn{2}{|c|}{\textbf{Inputs}}             & \multicolumn{2}{c|}{\textbf{Outputs}}                        \\ \hline
               \multicolumn{1}{|c|}{\textbf{in1}} & \textbf{in2} & \multicolumn{1}{c|}{\textbf{out1}}      & \textbf{out2}      \\ \hhline{|=|=|=|=|}
               \multicolumn{1}{|c|}{L}            & L            & \multicolumn{1}{c|}{GND}                & GND                \\ \hline
               \multicolumn{1}{|c|}{L}            & H            & \multicolumn{1}{c|}{GND}                & U$_{\text{BAT}}$ \\ \hline
               \multicolumn{1}{|c|}{H}            & L            & \multicolumn{1}{c|}{U$_{\text{BAT}}$} & GND                \\ \hline
               \multicolumn{1}{|c|}{H}            & H            & \multicolumn{1}{c|}{U$_{\text{BAT}}$} & U$_{\text{BAT}}$ \\ \hline
               \end{tabular}
               \end{table}
            \endgroup
            Über den Duty Cycle des PWM-Signals wird die Motorgeschwindigkeit gesteuert, über den DIR-Pin die Drehrichtung. Die Signale im zeitlichen Verlauf sind nachfolgend dargestellt.
            
            \begin{minipage}[H]{0.4\linewidth}
            \centering
            \begin{tikzpicture}
               \begin{axis}[
                  width=\linewidth,
                  height=2.5cm,
                  axis on top=false,
                  x axis line style={-stealth},
                  y axis line style={-stealth},
                  axis x line=center,
                  axis y line=center,
                  %title={Square wave},
                  xticklabels={},
                  ymin=0,xmin=0,
                  ymax = 4,xmax=7.5,
                  axis lines*=center,
                  ytick={0,3.3},
                  xlabel={ $t~\rightarrow$},
                  ylabel={$U_{\mathrm{PWMx}}$ [V]},
                  xlabel near ticks,
                  ylabel near ticks]
                  \addplot+[thick,mark=none,const plot]
                  coordinates
                  {(0,3.3) (1,0) (2,3.3) (3,0) (4,3.3) (5,0) (6,3.3) (7,0)};
                  \end{axis}
               \end{tikzpicture}
               \begin{tikzpicture}
                  \begin{axis}[
                     width=\linewidth,
                     height=2.5cm,
                     axis on top=false,
                     x axis line style={-stealth},
                     y axis line style={-stealth},
                     axis x line=center,
                     axis y line=center,
                     %title={Square wave},
                     xticklabels={},
                     ymin=0,xmin=0,
                     ymax = 4,xmax=7.5,
                     axis lines*=center,
                     ytick={0,3.3},
                     xlabel={ $t~\rightarrow$},
                     ylabel={$U_{\mathrm{DIRx}}$ [V]},
                     xlabel near ticks,
                     ylabel near ticks]
                     \addplot+[thick,mark=none,const plot,blue]
                     coordinates
                     {(0,0) (7,0)};
                     \end{axis}
                  \end{tikzpicture}
            \end{minipage}
            \hfill
            \begin{minipage}[H]{0.1\linewidth}
               $\xrightarrow[]{\text{L6206PD}}$
            \end{minipage}
            \hfill
            \begin{minipage}[H]{0.45\linewidth}
               
               \begin{tikzpicture}
                  \begin{axis}[
                     width=5cm,
                     height=4cm,
                     scale only axis = true,
                     x axis line style={-stealth},
                     y axis line style={-stealth},
                     restrict x to domain=0:7.5,
                     axis x line=center,
                     axis y line=center,
                     %title={Square wave},
                     xticklabels={},
                     yticklabels={,$U_{\mathrm{BAT}}$},
                     ymin=0,xmin=0,
                     ymax = 14,xmax=7.5,
                     axis lines*=center,
                     ytick={0,12},
                     xlabel={ $t~\rightarrow$},
                     ylabel={$U_{\mathrm{MTR}}$ [V]},
                     xlabel near ticks,
                     ylabel near ticks]
                     \addplot+[thick,mark=none,const plot,red]
                     coordinates
                     {(0,12) (1,0) (2,12) (3,0) (4,12) (5,0) (6,12) (7,0)};
                     \end{axis}
                  \end{tikzpicture}
               \end{minipage}

               Für $\mathrm{DIRx}=1$ ändert die Ausgangsspannung das Vorzeichen. Hierbei wird jedoch auch der Duty Cycle $D$ des Ausgangssignals invertiert, denn die Ausgangsspannung ist proportional zur Differenz der Eingangssignale, wie die nächste Graphik für $D=25\%$ zeigt.
               
               \begin{minipage}[H]{0.4\linewidth}
                  \centering
                  \begin{tikzpicture}
                     \begin{axis}[
                        width=\linewidth,
                        height=2.5cm,
                        x axis line style={-stealth},
                        y axis line style={-stealth},
                        axis x line=center,
                        axis y line=center,
                        %title={Square wave},
                        xticklabels={},
                        ymin=0,xmin=0,
                        ymax = 4,xmax=7.5,
                        axis lines*=center,
                        ytick={0,3.3},
                        xlabel={ $t~\rightarrow$},
                        ylabel={$U_{\mathrm{PWMx}}$ [V]},
                        xlabel near ticks,
                        ylabel near ticks]
                        \addplot+[thick,mark=none,const plot]
                        coordinates
                        {(0,3.3) (0.25,0) (1,3.3) (1.25,0) (2,3.3) (2.25,0) (3,3.3) (3.25,0) (4,3.3) (4.25, 0) (5,3.3) (5.25, 0) (6,3.3) (6.25,0) (7,0)};
                        \end{axis}
                     \end{tikzpicture}
                     \begin{tikzpicture}
                        \begin{axis}[
                           width=\linewidth,
                           height=2.5cm,
                           x axis line style={-stealth},
                           y axis line style={-stealth},
                           axis x line=center,
                           axis y line=center,
                           %title={Square wave},
                           xticklabels={},
                           ymin=0,xmin=0,
                           ymax = 4,xmax=7.5,
                           axis lines*=center,
                           ytick={0,3.3},
                           xlabel={ $t~\rightarrow$},
                           ylabel={$U_{\mathrm{DIRx}}$ [V]},
                           xlabel near ticks,
                           ylabel near ticks]
                           \addplot+[thick,mark=none,const plot,blue]
                           coordinates
                           {(0,3.3) (7,3.3)};
                           \end{axis}
                        \end{tikzpicture}
                     \end{minipage}
                     \hfill
                     \begin{minipage}[H]{0.1\linewidth}
                        $\xrightarrow[]{\text{L6206PD}}$
                     \end{minipage}
                     \hfill
                     \begin{minipage}[H]{0.45\linewidth}
                  \begin{tikzpicture}
                     \begin{axis}[
                        width=5cm,
                        height=4cm,
                        scale only axis = true,
                        x axis line style={-stealth},
                        y axis line style={-stealth},
                        restrict x to domain=0:7.5,
                        axis x line=center,
                        axis y line=center,
                        %title={Square wave},
                        xticklabels={},
                        yticklabels={,$U_{\mathrm{BAT}}$},
                        ymin=0,xmin=0,
                        ymax = 14,xmax=7.5,
                        axis lines*=center,
                        ytick={0,12},
                        xlabel={ $t~\rightarrow$},
                        ylabel={$-U_{\mathrm{MTR}}$ [V]},
                        xlabel near ticks,
                        ylabel near ticks]
                        \addplot+[thick,mark=none,const plot,red]
                        coordinates
                        {(0,0) (0.25,12) (1,0) (1.25,12) (2,0) (2.25,12) (3,0) (3.25,12) (4,0) (4.25,12) (5,0) (5.25,12) (6,0) (6.25,12) (7,0)};
                        \end{axis}
                     \end{tikzpicture}
                  \end{minipage}

            Somit muss hier der Duty Cycle über $D=100\%-D_{\mathrm{soll}}$ umgerechnet werden. Zur Ausgabe an den Pins wird der \textit{Compare} Wert für den Timer Channel berechnet, indem der Duty Cycle auf einen anteiligen Wert des vollen Rollovers (\ref{timer1}) skaliert wird. 
            \begin{align}
               \mathrm{COMPARE}=\mathrm{PERIOD} \cdot D
            \end{align}
        
            \subsubsection{Berechnung der PWM-Signale für die Mecanum-Räder}
            Die Berechnung der PWM-Signale erfolgt in einer eigenen Klasse aus den drei folgenden Werten: \Kotlin{VectorToMecanum.txt}{1}{5}
            \noindent Um diese Werte in ein PWM-Signal passend für die Mecanum-Räder umzurechnen, erfolgt zuerst eine additive Überlagerung der einzelnen Anteile. Wie diese Anteile überlagert werden, ist anhand des folgenden Bildes zu verdeutlichen. Für die Fahrt in y-Richtung drehen sich alle Motoren nach vorne. Folglich sind alle Einträge im Array 1. Analog für die Richtungen x und z.\\
            \begin{figure}[!ht]
                \centering
                \includegraphics[width=9cm]{img/Mecanum.png}
                \caption{Drehrichtungen der Mecanum-Räder \cite{wikipediaMecanum}}
            \end{figure}
            \FloatBarrier
            Für jeden Motor wird anhand folgender Richtungsarrays die Überlagerung durchgeführt. Motor 1 (erster Eintrag in Arrays) ist gemäß der Platine rechts unten, Motor 2 rechts oben, Motor 3 links oben und Motor 4 links unten:
            \Kotlin{VectorDirection.txt}{1}{5}
            Da es nun sein kann, dass der Maximalwert von 1 überschritten wird, werden bei einem Gesamtergebnis über 1 alle Ergebnisse mit einem Faktor so skaliert, dass das größte Ergebnis 1 entspricht. Dann kann aus dem Vorzeichen die Drehrichtung abgeleitet werden und aus dem Betrag des Ergebnisses das PWM-Signals durch eine Multiplikation mit hundert errechnet werden.
            
                
           \subsubsection{Ansteuerung des LED-Streifens}\label{ws2812}
            Als Statusanzeige wurde ein LED-Streifen, bestehend aus WS2812 LEDs, verwendet. Die ICs werden kaskadiert verschaltet und über eine gemeinsame Datenleitung angesteuert. Ein Kommando enthält die Farbwerte für alle LEDs, wobei jede LED 24 Bit erhält (8 Bit RGB). Die Daten werden gesammelt als ein Bitstrom versendet. Jede LED entnimmt dem Strom die ersten 24 Bits und leitet das gekürzte Datenpaket an die dahinter liegende weiter.
            Die Kodierung der Bits erfolgt durch bestimmte Timings, die folgender Grafik zu entnehmen sind.

            \vspace*{-0.7cm}
            \begin{minipage}[t]{0.45\linewidth}
               \begin{figure}[H]
                  \centering
                  \includegraphics[width=\linewidth]{img/ws2812-timing.png}
                  \caption{Kodierung eines Bits}
               \end{figure}
            \end{minipage}\hfill
            \begin{minipage}[t]{0.45\linewidth}
               \begin{table}[H]
                  \fontfamily{phv}\selectfont
                  \setlength{\tabcolsep}{10pt}
                  \centering
                  \begin{tabular}{|c|c|c|}
                  \hline
                  \textbf{Name}             & \textbf{Dauer} & \textbf{Toleranz} \\ \hline
                  T0H                       & 0.35\textmu s  & $\pm$150ns     \\ \hline
                  T1H                       & 0.70\textmu s  & $\pm$150ns     \\ \hline
                  T0L                       & 0.80\textmu s    & $\pm$150ns     \\ \hline
                  T1L                       & 0.60\textmu s  & $\pm$150ns     \\ \hline
                  $\text{TL}+\text{TH}$     & 1.25\textmu s      & $\pm$600ns     \\ \hline
                  RESET                     & $>$50\textmu s  &                                \\ \hline
                  \end{tabular}
                  \captionof{figure}{Einzuhaltende Timings}
                  \end{table}
            \end{minipage}
\subsubsection{Rückmessung der Encoder}
Für jedes Rad wird die aktuelle Drehzahl über Encoder zurückgemessen. Nur so kann ein stabiles Fahrverhalten erreicht werden, unabhängig von z.B. motorspezifischen Unterschieden oder der Akkuspannung.
Die Messung erfolgt über vier Interrupt-Pins. Mit jeder steigenden Flanke wird eine Zählvariable erhöht. In Intervallen wird dann die Anzahl der Flanken pro Zeiteinheit bestimmt. Hierrüber kann dann mit den Kenndaten des Encoders auf Umdrehungen pro Minute umgerechnet werden.
Die Motordrehzahl wird dann über einen abgewandelten PI-Regler kontrolliert, sodass die Drehzahl konstant gehalten und ein vorhersehbares Fahrverhalten erzielt werden kann. 


\newpage
\section{Aufbau und Funktionsweise der Android-App}


\subsection{Umsetzung}

Die App wurde in den \texttt{Android Platform APIs} umgesetzt. Als Programmiersprache wurde Kotlin gewählt. Das Interface wird in XML programmiert. Als Programmierumgebung wurde Android Studio gewählt. Als minimales API-Level wurde 26 festgelegt. Damit kann die App auf allen Android-Geräten mit mindestens Android 8.0 installiert werden. Im Gegensatz zu klassischen Programmen, wird der Entry-Point zum Programm nicht durch eine Main-Funktion festgelegt. Das Rendern des Interfaces, Verwalten von Events und Halten von Variablen erfolgt in Android durch Activities (siehe auch \ref{activies}). Damit in der gesamten App die Bluetooth-Verbindung zum Roboter gehalten werden kann, wird mit Ausnahme des zur Herstellung der Bluetooth-Verbindung verwendeten Interfaces, nur eine Activity für die gesamte App verwedet. Damit trotzdem verschiedene Interfaces angezeigt werden können, wird extensiv von Android-Fragments und -Dialogs Gebrauch gemacht.


\subsection{Herstellen einer Bluetooth Verbindung}


\subsubsection{Server und Client}

In jeder Bluetooth Verbindung versteht sich ein Gerät als Server, während das andere als Client auftritt. Hierbei unterscheiden sich beide nur dadurch, dass der Client die Verbindung initialisiert und der Server die Verbindung akzeptiert. Sobald die Verbindung hergestellt wurde, können beide Partner Daten senden und empfangen, sowie die Verbindung terminieren. Da der Benutzer in der App aktiv eine Verbindung mit dem Roboter herstellen wird, versteht sich hier die App als Client und der LFR als Server. Auf dem Raspberry Pi muss also ein Programm eingehende Anfragen abfangen und annehmen.


\subsubsection{Pairing}

Bevor eine Bluetooth-Verbindung hergestellt werden kann, muss zwischen den beiden Geräten ein Pairing Prozess durchlaufen werden. Dabei werden Gerätedaten und Schlüssel für eine gesicherte Übertragung ausgetauscht. Diese Daten werden lokal gespeichert, sodass das Pairing nur einmal durchgeführt werden muss, solange diese nicht manuell aufgehoben wird. Da Pairing außerdem auch auf dem Raspberry Pi Benutzereingabe erfordern würde, da ein blindes Akzeptieren aller eingehenden Anfragen zu schweren Sicherheitsrisiken führt, wird diese Funktion nicht in das Programm übernommen und muss vor der Nutzung der Robot Controller App manuell auf dem Smartphone durchgeführt werden.


\newpage
\subsubsection{Vorbereiten der Verbindung}

Um eine Verbindung von der App aus zu initialisieren, wird die Bluetooth-Adresse des Raspberry Pi benötigt. Da bereits eine Kopplung zwischen den beiden Geräten besteht, kann die App eine Anfrage nach allen gekoppelten Geräten stellen. Dies liefert eine Liste von Objekten der Klasse BluetoothDevice, welche unter anderem Gerätename und -adresse enthalten. Somit kann der Benutzer den Roboter aus einer Liste von Geräten auswählen und die Verbindung auf Knopfdruck initialisieren.


\subsubsection{Bluetooth-Sockets}

Die Endpunkte einer Bluetooth-Verbindung werden Sockets genannt, die jeweils von Client und Server erstellt werden. Die Erstellung des Server-Sockets wird im Kapitel Raspberry Pi beschrieben. Unter der Android API können Client-Sockets direkt aus einem \texttt{BluetoothDevice} erstellt werden. Durch ein Aufrufen der connect() Funktion wird die Verbindung initialisiert und falls diese vom Server akzeptiert wird, kann der Datentransfer beginnen.


\subsection{Format der Bluetooth-Nachrichten}

Um die Interpretation der Daten zu vereinfachen, haben in diesem Projekt alle Bluetooth-Nachrichten eine feste Länge. Nachrichten von der App zum Roboter sind immer 10 Bytes lang, wobei Nachrichten in die andere Richtung eine Länge von 16 Bytes aufweisen. Das erste Byte der Nachrichten ist immer die \texttt{Command ID}. Sie beschreibt welchen Inhalt die Nachricht hat, z.B. `\texttt{drive vector}` oder `\texttt{sensor data}`. Anders als bei der UART-Verbindung zwischen Raspberry Pi und STM, wird hier keine Prüfsumme verwendet, da das Bluetooth-Protokoll bereits eine sichere Datenübertragung bereitstellt.

Die hier verwendete Art von Bluetooth-Verbindung erlaubt nur das Versenden von einzelnen Bytes, es kennt keine Datentypen. Damit Daten wie z.B. Gleitkommazahlen versendet werden können, müssen diese in rohe Bytes umgewandelt werden. Die Android API stellt hier die \texttt{ByteBuffer}-Klasse zur Verfügung. Hier ist es noch wichtig, dass beide Systeme die gleiche Byte-Reihenfolge (Endianess) verwenden. Der Raspberry Pi verwendet das Little-Endian-System, die \texttt{ByteBuffer}-Klasse verwendet standardmäßig Big-Endian, unterstützt aber beide Systeme, sodass nach Konfiguration des \texttt{ByteBuffers} beide Partner miteinander kommunizieren können.


\newpage
\subsection{Die App im manuellen Modus}

\begin{minipage}{\linewidth}
   \centering
   \captionsetup{type=figure, justification=centering}
   \includegraphics[width=0.75\linewidth]{img/app_manual.png}
   \caption{Manuelles Steueren des Roboters über die App}
\end{minipage}
\vspace*{0.25cm}

Im manuellen Modus kann der Roboter voll durch die App gesteuert werden. Die Fahrdaten werden periodisch an den Raspberry Pi übertragen. Die App erhält vom Pi unter anderem Batteriespannung und -strom und zeigt diese dem Benutzer an. Die Steuerung der Fahrtrichtung erfolgt über einen virtuellen Joystick. Da es in der Android API hierfür keine vorgefertigte View gibt, wurde dieser selbst implementiert. Hierbei wird es dem Benutzer ermöglicht einen Kreis in einer begrenzten Fläche zu bewegen. Der Fahrtvektor wird dann durch Berechnung des Abstands zum Mittelpunkt des Joysticks ermittelt. Auf der rechten Seite kann der Benutzer die Fahrgeschwindigkeit des Roboters einstellen. Diese wird mit in den Fahrtvektor eingerechnet, sowie für die Rotation verwendet. Hierbei lassen sich durch einen vertikalen Slider Geschwindigkeiten zwischen 50\% und 100\% einstellen. Die Rotation des Roboters lässt sich über zwei Buttons auf der linken Seite des Bildschirms steueren.


\subsection{Die Sensor-Anlernroutine}

\begin{minipage}{\linewidth}
   \centering
   \captionsetup{type=figure, justification=centering}
   \includegraphics[width=0.75\linewidth]{img/app_auto_learn.png}
   \caption{Anlernen der Sensoren über die App}
\end{minipage}
\vspace*{0.25cm}

Da die Werte der Infrarotsensoren von Lichtverhältnissen, Einbauhöhe und anderen Faktoren beeinflusst werden, ist vor dem Starten des Line-Following- oder Routenmodus eine Anlernroutine notwendig. Diese kann durch eine Schaltfläche in der App gestartet werden. Nach kurzer Wartezeit fährt der Roboter langsam vorwärts und analysiert die Sensorwerte. Durch Mitteln über die gefundenen Sensorwerte können Schwellenwerte für Linien und Hintergründe festgelegt werden. Diese werden auf dem Raspberry Pi gespeichert und außerdem an die App gesendet, damit sie vom Benutzer eingesehen und auf Plausibilität überprüft werden können. Nach jedem Neustart des Roboters ist erneutes Anlernen notwendig.


\subsection{Die App im Line-Following-Modus}

\begin{minipage}{\linewidth}
   \centering
   \captionsetup{type=figure, justification=centering}
   \includegraphics[width=0.75\linewidth]{img/app_auto_follow.png}
   \caption{Line-Following in der App}
\end{minipage}
\vspace*{0.25cm}

Während des Line-Followings halten sich die Benutzereingaben in Grenzen. Sobald das Line-Following in der App selektiert wurde, beginnt der Roboter mit der Fahrt. Es kann in der App nur die Geschwindigkeit des Roboters durch einen horizontalen Slider gesteuert werden. Hier lassen sich wieder Werte von 50\% bis 100\% einstellen. Zusätzlich zu den Batteriedaten werden noch die Drehzahlen der vier Motoren angezeigt. Hierbei korrespondiert die Position der Anzeige in der App direkt mit der Position der Motoren am Roboter. Am oberen Rand des Bildschirms werden außerdem die momentanen Werte der Sensoren angezeigt. Das Betätigen der \texttt{Stop}-Schaltfläche, oder das Schließen der App, führt zu sofortigem Stillstand des Roboters.


\newpage
\subsection{Die App im Routenmodus}

\begin{minipage}{\linewidth}
   \centering
   \captionsetup{type=figure, justification=centering}
   \includegraphics[width=0.75\linewidth]{img/app_auto_route_create.png}
   \caption{Erstellen eines Punktenetzes in der App}
\end{minipage}
\vspace*{0.25cm}

Die App ermöglicht es dem Benutzer die verwendeten Checkpoints zu erstellen und zu verbinden. Das Hinzufügen eines Punkts erfolgt über Einscannen des QR-Codes. Es wird außerdem ein Name für den Punkt vergeben, welcher allerdings nur in der App als Komfortfunktionn implementiert ist und nicht an den Roboter gesendet wird. Durch Auswählen eines Punktes kann dieser entweder gelöscht werden, oder eine Verbindung zu einem anderen Punkt hinzugefügt werden. Hierbei wird der Zielpunkt spezifiziert, sowie die Richtung der Verbidung festgelegt und bestimmt, ob der Roboter den Punkt in diese Richtung verlassen darf, oder ob es sich um eine Verbindung mit nur einer Fahrtrichtung handelt. Als Sonderfall tritt hier der imaginäre Punkt \texttt{null (0)} auf. Dieser kann dem Netz nicht hinzugefügt, sondern nur als Verbindung zu anderen Punkten festgelegt werden. Außerdem kann der Roboter das Netz nicht in Richtung Punkt \texttt{null} verlassen. Dieser Punkt wird im Roboter als Anfangszustand gesetzt, wenn der Routenmodus beginnt. Somit kann der Roboter bereits beim ersten Punkt seine Orientierung ermitteln. Nachdem ein Punktenetz erstellt wurde, kann dieses im lokalen Dateiensystem der App gespeichert und später wieder geladen werden. Wählt der Benutzer nun die Schaltfläche \texttt{Next}, so werden die Punktedaten an den Roboter übertragen. Dieser speichert diese und beginnt den Routenmodus.

\newpage

\begin{minipage}{\linewidth}
   \centering
   \captionsetup{type=figure, justification=centering}
   \includegraphics[width=0.75\linewidth]{img/app_auto_route.png}
   \caption{Appsteuerung des Roboters im Routenmodus}
\end{minipage}
\vspace*{0.25cm}

Der Roboter beginnt den Routenmodus, als hätte er gerade den imaginären Punkt \texttt{null} verlassen. Er startet das reguläre Line-Following bis er einen Checkpoint findet. Diese werden durch eine dicke Linie, quer zur Fahrbahn, gekennzeichnet. Eine Kennzeichnung nur durch die Präsenz eines QR-Codes ist nicht ausreichend, da während der Fahrt die Erkennung mit der Kamera nicht hundertprozentig zuverlässig ist. Sobald ein Punkt gefunden wurde, zentriert sich der Roboter darauf und bleibt stehen.

Befindet sich der Roboter in Bereitschaft auf einem Checkpoint, so kann ein Ziel in der App gewählt werden. Das Ziel muss hierbei nicht direkt mit dem aktuellen Punkt verbunden sein, der Roboter findet dann die schnelleste Route zum gewählten Punkt. Hat der Roboter eine Route bestimmt, so begibt er sich auf den Weg zum Ziel. Solange das Ziel nicht erreicht wurde, kann keine weitere Zieleingabe durchgeführt werden. Am oberen Bildschirmrand wird immer der aktuelle Status des Roboters angezeigt. Hier lässt sich zum Beispiel erkennen, ob der Roboter z.B. gerade einen Punkt sucht, oder sich in Fahrtrichtung ausrichtet.


\newpage
\section{Raspberry Pi}

\subsection{Allgemeines}

Der Raspberry Pi bildet eine Schnittstelle zwischen der Android-App und dem STM32.
Neben der Nutzung des Pi's als Schnittstelle wird der Algorithmus für das Line-Following und für die Routenplanung darauf ausgeführt. Zusätzlich ist über ein Flachbandkabel eine Pi-Cam zur Erkennung von QR-Codes mit dem Microcomputer verbunden. Für die Programmierung der Algorithmen wurde auf die Programmiersprache C++ mit dem GNU C++ Compiler zurückgegriffen. Als Build-Tool wurde CMake verwendet.

\subsection{Bluetooth-Verbindung}

Die Bluetooth-Verbindung wird mit Hilfe des Headers \texttt{bluetooth.h} aus dem unter Linux vorinstallierten \texttt{libbluetooth-dev} Paket realisiert. Beim Programmstart wird ein offener Bluetooth-Socket in einem neuen Thread erstellt. Somit werden alle eingehenden Bluetooth-Verbindungen von gekoppelten Geräten akzeptiert. Es kann immer nur ein Gerät mit dem Pi verbunden sein. Sobald die Verbindung etabliert wurde, können Daten von der App empfangen, sowie Nachrichten zur App gesendet werden.

\subsection{UART-Kommunikation}

Unter Linux wird eine UART-Verbindung als eine Datei behandelt, die gelesen und beschrieben werden kann. Für das Öffnen der Datei wird der systemeigenen Header \texttt{fcntl.h} benötigt. Das Konfigurieren der Verbindung wird durch \texttt{termios.h} ermöglicht. Um die Datei öffnen zu können wird \texttt{unistd.h} benötigt. Alle diese Header sind unter Linux vorinstalliert.

Die UART-Kommunikation ist verbindunglos, d.h. es existiert kein Verbindungsaufbau und keine Empfangsbestätigungen. Ein Teilnehmer kann dadurch Daten senden, ohne dass der Empfänger dafür bereit ist. Um trotzdem eine zuverlässige Datenübertragung zu ermöglichen, beginnen alle Nachrichten mit dem selben Anfangsbyte und enden mit einer Prüfsumme (vgl. \ref{uart-code}). Die Länge der Nachrichten ist außerdem auf 12 Byte im Senden und 16 Byte im Empfangen festgelegt.

Sobald das Programm auf dem Pi gestartet wurde, kann es in einem seperaten Thread Daten vom STM32 empfangen und speichern. Es erhält somit regelmäßig Batteriespannung und -strom, die Motordrehzahlen und die Sensorwerte. Sobald eine Bluetooth-Verbindung hergestellt wurde, beginnt der Pi regelmäßig den Richtungsvektor, die Fahrgeschwindigkeit und die Drehrichtung des Roboters zu senden, auch wenn der Roboter sich nicht bewegen soll.


\newpage

\subsection{Manueller Modus}

Im manuellen Modus schleift der Raspberry Pi nur die Signale zwischen der Android-App und dem STM32 durch. Der STM32 erhält die Fahrdaten und die App die Batterie- und Motordaten zurück. Der Pi stellt dabei nur sicher, dass die übermittelten Daten valide sind und die Teilnehmer in festen Zeitabständen erreichen. Außerdem wird sichergestellt, dass bei Verlust der Bluetooth-Verbindung der Roboter angehalten wird.


\subsection{Line-Following Modus}

Im Line-Following Modus transferiert der Pi wieder die Batterie- und Motordaten vom STM32 zur Android App. Außerdem werden die Sensordaten an die App übertragen. Die Fahrdaten werden in diesem Modus aber nicht von der App gesendet, sondern durch den Pi erzeugt.

\newcommand{\Kd}{K_D}
\newcommand{\Ki}{K_I}
\newcommand{\Kp}{K_P}
\newcommand{\Ts}{T_S}

Die Regelung des Roboters erfolgt durch einen PID-Regler im geschlossenen Regelkreis. Dabei ist $e(t)$ die Differenz des Sollwerts $u(t)$ und dem Istwert $y(t)$. Die Implementierung erfolgt anhand folgender Herleitung:
\begin{align}
   u(t) = \Kp\cdot e(t)+\Ki\cdot \int_{0}^{t}e(\tau)\text{d}\tau+\Kd\cdot\dfrac{\text{d}e(t)}{\text{d}t}
\end{align}

Die einzelnen Terme können im diskreten Zeitbereich wie folgt angenähert werden. Für den Integralteil erfolgt die Trapeznäherung.
\begin{align}
   \int_{0}^{t}e(\tau)\text{d}\tau &\approx\sum_{n=1}^{k}\dfrac{e[k]+e[k-1]}{2}\cdot T_S\\[0.2cm]
   \dfrac{\text{d}e(t)}{\text{d}t}&\approx\dfrac{e[k]-e[k-1]}{T_S}
\end{align}

Setzt man diese Terme nun zusammen und bildet $u[k]-u[k-1]$ erhält man:
\begin{align}
   u[k] = u[k-1]&+\Kp\cdot\left(e[k]-e[k-1]\right)+\Ki\cdot\left(\dfrac{e[k]+e[k-1]}{2}\cdot T_S\right)\\
   &+\Kd\cdot\left(\dfrac{e[k]-2\cdot e[k-1]+e[k-2]}{\Ts}\right)\nonumber
\end{align}

Der Sollwert wird als Mittelwert aller Sensoren berechnet, wobei die äußeren Sensoren eine höhere Gewichtung haben. Falls kein Sensor ein Signal liefert, wird es so betrachtet, als wäre die Linie zwischen den mittleren Sensoren. Der Ausgangswert des Reglers wird im Anschluss wieder in Bewegungsvektor und Drehrichtung umgerechnet. Hierdurch resultiert bei kleinem Reglerausschlag ein langer Vektor in Vorwärtsrichtung, der bei kleinen Werten gegen null geht. Die Drehung des Roboters wird mit dem Ausgangssignal hochskaliert. Eine Bewegungsrichtung längs zum Fahrzeug wird im Line-Following-Modus nicht verwendet. Der Roboter verhält sich wie ein Fahrzeug mit regulären Rädern.

Als Zeitkonstante $T_S$ wurde 1ms gewählt. Der Regler wird im Programm alle $T_S$ aufgerufen. Die experimentelle Einstellung hat ergeben, dass der D-Anteil wenig sinnvoll ist. Deshalb werden die Konstanten $\Kd = 0$, $\Ki = 0.005$ und $\Kp = 1\cdot 10^{-5}$ gewählt. Diese kleinen Zahlen resultieren aus der sehr kleinen Zeit $\Ts$.

Bei scharfen Kurven verlässt der Roboter oft die Linie, da der zeitliche Verzug des Reglers zu groß ist. Deshalb wird bei Ausschlagen der äußeren Sensoren der Ausgangswert des Reglers so gesetzt, dass der Roboter schnell einlenkt.


\subsection{Routenmodus}

Im Routenmodus erfüllt der Pi grundsätzlich die selben Aufgaben wie im Line-Following Modus. Zwischen zwei Checkpoints werden hier auch die selben Algorithmen angewandt. Zusätzlich wird allerdings ein neuer Thread erstellt, worin die QR-Code-Erkennung mithilfe der Pi-Cam abläuft. Da eine Implementierung in C++ sehr komplex wäre, werden hier die Funktionalitäten von \texttt{Python.h} aus dem \texttt{Python API for C} verwendet. Dadurch kann im C++ Code ein Python Interpreter gestartet werden, der die QR-Code-Erkennung verwaltet und die Ergebnisse an das Programm meldet.

Folgt der Roboter im Routenmodus einer Linie und erkennt einen Checkpoint, so läuft eine vordefinierte Schrittkette ab. Zuerst bleibt der Roboter stehen, um den QR-Code des Punkts zu analysieren. Hat er diesen erkannt, fährt er ein Stück vorwärts, um sich auf dem Punkt zu zentrieren. Falls er noch nicht am Ende seiner Route angekommen ist, dreht er sich in Richtung des gewünschten Ausgangs. Dann verlässt er den Punkt, wobei das Line-Follwing erst nach einer kurzen Wartezeit wieder aktiviert wird, damit der Punkt selber nicht als Linie erkannt wird.

Damit der Roboter von jedem Checkpoint zu einem anderen fahren kann, auch wenn keine direkte Verbindung besteht, ist ein Pathfinding-Algorithmus notwendig. Hier wurde eine Implementierung des Dijkstra-Algorithmus realisiert. Erhält der Roboter einen Zielpunkt von der Android-App, so berechnet er die schnellste Route und speichert die zu befahrenden Punkte. Bis alle Punkte abgefahren wurden, kann kein neuer Zielpunkt mehr festgelegt werden.


\newpage
\section{Diskussion der Alternativen}

Als erstes sollen die Hardwarealternativen beleuchtet werden. Anstatt des RaspberryPi wäre ein ESP32 in Frage gekommen. Dieser verfügt sowohl über eine Bluetooth-Schnittstelle, als auch über einen UART-Funktion, der für die Kommunikation mit dem STM wichtig ist. Mit einem Cam-Module wäre hier auch das Einlesen der QR-Codes möglich gewesen. Ein Punkt der gegen den Pi spricht ist, dass keine Interrupts implementiert werden können, sodass ein dauerhaftes Abfragen der Bluetooth- und UART-Verbindung, sowie des Kamera-Framebuffers notwendig ist. Dadurch verwendet das Programm alle vier Kerne des RaspberryPi-Prozessors, auch wenn tatsächlich deutlich weniger Rechenleistung notwendig wäre. Dennoch ist die Wahl auf den RaspberryPi 4 gefallen, da dieser schon vorhanden war und auch deutlich mehr Rechenleistung bietet, als ein ESP32-Chip.

Die Erkennung der Linie wäre auch mit einer Kamera und softwareseitiger Bildverarbeitung möglich. Da dies jedoch sehr aufwendig ist und bei nicht idealer Implementieren zu langen Zykluszeiten führen kann, haben wir uns für eine Lösung mit Infrarotsensoren entschieden, die in einer Halterung vor dem Roboter knapp über dem Boden hängen. Diese können vom STM als Ganzzahlenwerte eingelesen werden und somit einfach in der Software verarbeitet werden.

Softwareseitig war anfangs eine Umsetzung des Programms auf dem Pi in Python geplant. Auch wenn die Umsetzung der Kommunikationen und das Analysieren der QR-Codes dort umkompliziert waren, lässt sich aufgrund des GIL kein Multithreading umsetzen. Deshalb ist die Wahl auf C++ gefallen. Dort muss UART und Bluetooth zwar deutlich näher an der Hardware umgesetzt werden, jedoch lassen sich diese in seperate Threads auslagern. Außerdem hat sich C++ als deutlich performanter herausgestellt.


\chapter{Ergebnisse}

Im Rahmen dieses Projektes ist ein funktionsfähiger Line-Following-Roboter entstanden, der einer Linie unabhängig vom Material des Hintergrunds folgen kann. Außerdem ist eine manuelle Steuerung des Roboters möglich. Zusätzlich kann eine Route festgelegt werden, wobei sich der Roboter an QR-Codes orientiert, sodass der Roboter dieser eigenständig folgen kann.

Die Steuerung des Roboters erfolgt über eine Android-App. Hier kann man neben dem manuellen Modus, in dem sich der Roboter mit einem Joystick steuern lässt, in den Automatikmodus bzw. den Navigationsmodus wechseln. Im Navigationsmodus können QR-Codes eingelesen werden und somit eine feste Strecke eingespeichert werden, die der Roboter dann autonom abfahren kann.

Zur Ansteuerung der Motoren und zum Einlesen der Infrarotsensoren ist eine Platine entwickelt worden, die von einem 12V-Akku gespeist wird. Über die Platine wird auch der RaspberryPi mit Strom versorgt. Die Datenübertragung zwischen RaspberryPi und STM wurde mit einer UART-Kommunikation realisiert. Zur Kommunikation zwischen Pi und Android App wird eine Bluetooth-Verbindung eingesetzt.

Außerdem wurde im Rahmen der Projektarbeit eine 3D-gedruckte, höhenverstellbare Sensoraufhängung sowie eine Halterung für die RaspberryPi Cam gefertigt. Zusätzlich wurden vier Alumunium-Naben selbst angefertigt, um eine passgenaue Montage der Motoren am Gehäuse zu gewährleisten.


\chapter{Zusammenfassung und Ausblick}
Die Projektanforderungen, die zu Beginn festgelegt wurden, konzentrierten sich vor allem auf das Implementieren des Line-Followings, also das autonome Abfahren einer linienartigen Bodenmarkierung, wobei zunächst manuelle Fahrten umgesetzt werden sollten.

Die mechanische Basis des Fahrzeugs war vorgegeben und entsprang eines zur Verfügung gestellten Roboters, der nur geringfügig angepasst wurde. Der Fokus lag auf den für die Funktionen notwendige elektrotechnischen Komponenten einschließlich der Software. Es wurde eine Platine selbst geplant und angefertigt, die die Erfüllung der Aufgabenstellung unterstützt. Mit dieser wurde die gesamte Spannungsversorgung, Sensor- und Motoransteuerung sowie die Kommunikation eigenständig software- und hardwareseitig implementiert. Weiter wurde die gesamte, den Line-Following-Algorithmus betreffende, Software auf dem Raspberry Pi konzipiert und umgesetzt. Der eigens erstellte und angepasste PID-Regler wandelt die Sensorrohwerte in Fahrdaten für das Line-Following. Über die ursprünglichen Anforderungen hinaus wurde eine komplette Smartphone-App entwickelt, die die Steuerung des Fahrzeugs vereinfacht. Außerdem konnte, unter Benutzung einer Kamera, ein Pathfinding-Algorithmus umgesetzt werden, mit dem das Fahrzeug durch ein durch Kreuzungen verbundenes Liniennetz navigieren und steuern kann. Insgesamt wurden die ursprünglichen Anforderungen also vollumfänglich erfüllt und teilweise auch übertroffen.

Zukünftige Verbesserungen des Fahrzeugs könnten sich auf die Optik beziehen, da bis jetzt kein Gehäuse angefertigt wurde. Hier kann auch über die Erweiterung der Beleuchtung nachgedacht werden. Außerdem wäre eine weitere Optimierung des Line-Following-Reglers erstrebenswert, damit eine gleichmäßige und genaue Regelung auch bei höhren Geschwindigkeiten durchgeführt werden kann. Eine komplette Neukonzipierung der Regelung über eine zunächst rein theoretische Herleitung der Reglerparameter in Kombination mit einer vorherigen Simulation könnte eine vollumfängliche fundierte Lösung bieten. Hierfür können auch die Sensorpositionen bzw. Liniendicken weiter verbessert werden, um eine genauere und zuverlässigere Linienerkennung zu erzielen. Im gleichen Zuge kann über den Austausch des RaspberryPi durch einen kostengünstigeren aber vom Funktionsumfang ausreichenden ESP32 nachgedacht werden, bei dem eine effizientere Nutzung der Hardwareressourcen möglich wäre.

\bibliography{ref}

\end{document}
